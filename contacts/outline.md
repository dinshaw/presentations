# Contact 2 Talk
## intro
Meet the SLA's what does SLA mean?
In hopes of making this talk accesible to eeryone, I am going to try and ekplain things that may be obvious to some. if you're not a novice, feel free to correct me!
one of the reasons i'm catering to a novice crowd is because that is what we are working with as we build rails in large teams. Why do I say this? There is no more mature talent on the market. We have a very active apprentice program. When we started buildinvg this app, we were faced with the Unique problem of app having to work at a scale that most startups don't hit for the lifetime of the business, as soon as we throw the switch.
I'm going to walk through our two-year road from design to full adoption.
TL;DR :
Compostite primary keys are amazing
Don't ues AR, if you're never going to need it

Pull requests
Code reviews
KISS

But this is more than a story of Rails at scale, its also a story of acquisition and cultural assimilation.
Large team issues:
** Not everyone on your team is going to be a rockstar
** tech lead will miss something
## Beginning

** Choose your battles


## Middle
Things we did?
Tools we used?
Tools we should have used?

### Initial Development
Three
* Migrations are a big deal - how do we handle them now?
* Start with a normal app
* No bootstrap


### The path
* choose tec
* Change tec
* Begin to scale
* v2 api/ tdd
* Brian's Golang tool surfaced import slowness (v2 api)
* Dtrace surfaced more bottlenecks
* Single threaded benchmarks not accurate
* Tom
** Batch processing
* Andre
** Jackson for json
** What's happening in loops?
** HTML was generated by rubyporfiler (mri)
- in app.rb, block around the rack request
** The benchmark do was better for looking at trends
- Now this can be done with new relic
** 500 Contact load was 40sec
- Got db down to 12ms, still taking 4 seconds
- Java built contacts query tool never went to AR - down to 385ms
* DB Refactor
** Composite keys
- explain disk partitioning
* Brain
** Patched CPK gem

    https://github.com/strmpnk/composite_primary_keys/commit/21e081359eaa60a6b67bb1b999dbe4da23149f47

- Megamorphic problem

    class Foo
      def do_something
      end
    end

    class Bar
      def do_something
      end
    end

    a = [Foo.new, Bar.new] * 1000
    a.each { |obj|
      # inline cached, eventually JITs
      obj.do_something
    }

    # inline cached code path
    case obj.class
    when Foo
      Foo.do_something
    when Bar
      Bar.do_something
    else
      lookup ...
    end


- Jruby hit compiling worse than ruby because its more aggressive
- Explain singleton issue
- inline cache
- trace surfaced more v2 slowness
* Eagar load vs preload vs include
* V3 Api
* Dead code and git blame!
* Ownership, look for problems, question everything
* People are explaining stuff, don't try to be cool, make them explain it - if they can't, it probably doesn't work
* Replace JSON
* People will burnout on the same shit - careful mgrs! - pair up to avoid this
* What's the biggest value of pair-programming? Company.
* Benchmark
* Profile

#### Tom
Redis runs as a single service per cell. Caching became a bottle neck
Too much caching led to threads grabbing a db connection and then waiting for redis.
Careful what you cache! Memcached is multi-threaded, could maybe use that these days.

DB: Composite key optiomized query, then we partitioned (physical separation by account_id).
Why wheren't we getting 12 partitions? ask alex!

500 insert - wikipage for import

Contacts Selector could have been done in Ruby, java was a reactionary choice. Might save some translation time.

Connection pools: TB was not returning connections in v2.x, needed to wrap in connection block.
## End
Things we would do differently?
Do we work differently now?

Build a normal app
